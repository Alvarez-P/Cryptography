(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{362:function(t,s,a){"use strict";a.r(s);var e=a(25),o=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"salted-passwords"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#salted-passwords"}},[t._v("#")]),t._v(" Salted Passwords")]),t._v(" "),a("p",[t._v("In the previous lesson, we explained why it is better to store hashed passwords. But a file of passwords encrypted with a hash function is still vulnerable. Let’s imagine that a hacker compiles a list of the million most common passwords. He operates on all the million of them with the hash function and stores the results.  Now, the hacker steals a list of hash values stored in the database. He compares that list with his list of encrypted possible passwords and discovers possible matches.\nThis is called a dictionary attack.\nSalt is a way to make it more difficult.")]),t._v(" "),a("p",[a("strong",[t._v("Salt")]),t._v(" is a random string that is concatenated with the password before hashing it. Both the salt value and the result of the hash function are stored in the database on the host. If the number of possible salt values is large enough, this practically eliminates a dictionary attack against commonly used passwords because the hacker has to generate the one-way hash for each possible salt value.")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("Salt only protects against general dictionary attacks on a password file, not against a concerted attack on a single password. It protects people who have the same password on multiple machines but doesn’t make poorly chosen passwords any better.")])])])}),[],!1,null,null,null);s.default=o.exports}}]);